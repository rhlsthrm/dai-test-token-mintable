"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const ethereumjs_vm_1 = __importDefault(require("@nomiclabs/ethereumjs-vm"));
const exceptions_1 = require("@nomiclabs/ethereumjs-vm/dist/exceptions");
const state_1 = require("@nomiclabs/ethereumjs-vm/dist/state");
const promisified_1 = __importDefault(require("@nomiclabs/ethereumjs-vm/dist/state/promisified"));
const chalk_1 = __importDefault(require("chalk"));
const debug_1 = __importDefault(require("debug"));
const ethereumjs_account_1 = __importDefault(require("ethereumjs-account"));
const ethereumjs_block_1 = __importDefault(require("ethereumjs-block"));
const ethereumjs_common_1 = __importDefault(require("ethereumjs-common"));
const ethereumjs_tx_1 = require("ethereumjs-tx");
const ethereumjs_util_1 = require("ethereumjs-util");
const secure_1 = __importDefault(require("merkle-patricia-tree/secure"));
const util_1 = require("util");
const default_config_1 = require("../../core/config/default-config");
const project_structure_1 = require("../../core/project-structure");
const compiler_to_model_1 = require("../stack-traces/compiler-to-model");
const consoleLogger_1 = require("../stack-traces/consoleLogger");
const contracts_identifier_1 = require("../stack-traces/contracts-identifier");
const revert_reasons_1 = require("../stack-traces/revert-reasons");
const solidity_errors_1 = require("../stack-traces/solidity-errors");
const solidityTracer_1 = require("../stack-traces/solidityTracer");
const vm_tracer_1 = require("../stack-traces/vm-tracer");
const blockchain_1 = require("./blockchain");
const errors_1 = require("./errors");
const utils_1 = require("./utils");
const log = debug_1.default("buidler:core:buidler-evm:node");
// This library's types are wrong, they don't type check
// tslint:disable-next-line no-var-requires
const ethSigUtil = require("eth-sig-util");
exports.COINBASE_ADDRESS = ethereumjs_util_1.toBuffer("0xc014ba5ec014ba5ec014ba5ec014ba5ec014ba5e");
class TransactionExecutionError extends Error {
}
exports.TransactionExecutionError = TransactionExecutionError;
exports.SUPPORTED_HARDFORKS = [
    "byzantium",
    "constantinople",
    "petersburg",
    "istanbul"
];
class BuidlerNode {
    constructor(_vm, _blockchain, localAccounts, _blockGasLimit, genesisBlock, _throwOnTransactionFailures, _throwOnCallFailures, stackTracesOptions) {
        this._vm = _vm;
        this._blockchain = _blockchain;
        this._blockGasLimit = _blockGasLimit;
        this._throwOnTransactionFailures = _throwOnTransactionFailures;
        this._throwOnCallFailures = _throwOnCallFailures;
        this._accountPrivateKeys = new Map();
        this._blockTimeOffsetSeconds = new ethereumjs_util_1.BN(0);
        this._transactionByHash = new Map();
        this._transactionHashToBlockHash = new Map();
        this._blockHashToTxBlockResults = new Map();
        this._blockHashToTotalDifficulty = new Map();
        this._lastFilterId = 0;
        this._blockFiltersLastBlockSent = new Map();
        this._nextSnapshotId = 1; // We start in 1 to mimic Ganache
        this._snapshots = [];
        this._stackTracesEnabled = false;
        this._consoleLogger = new consoleLogger_1.ConsoleLogger();
        this._failedStackTraces = 0;
        const config = project_structure_1.getUserConfigPath();
        this._stateManager = new promisified_1.default(this._vm.stateManager);
        this._common = this._vm._common; // TODO: There's a version mismatch, that's why we cast
        this._initLocalAccounts(localAccounts);
        this._blockHashToTotalDifficulty.set(ethereumjs_util_1.bufferToHex(genesisBlock.hash()), this._computeTotalDifficulty(genesisBlock));
        this._getLatestBlock = util_1.promisify(this._vm.blockchain.getLatestBlock.bind(this._vm.blockchain));
        this._getBlock = util_1.promisify(this._vm.blockchain.getBlock.bind(this._vm.blockchain));
        this._vmTracer = new vm_tracer_1.VMTracer(this._vm, true);
        this._vmTracer.enableTracing();
        if (stackTracesOptions !== undefined) {
            this._stackTracesEnabled = true;
            try {
                const bytecodes = compiler_to_model_1.createModelsAndDecodeBytecodes(stackTracesOptions.solidityVersion, stackTracesOptions.compilerInput, stackTracesOptions.compilerOutput);
                const contractsIdentifier = new contracts_identifier_1.ContractsIdentifier();
                for (const bytecode of bytecodes) {
                    contractsIdentifier.addBytecode(bytecode);
                }
                this._solidityTracer = new solidityTracer_1.SolidityTracer(contractsIdentifier);
            }
            catch (error) {
                console.warn(chalk_1.default.yellow("Stack traces engine could not be initialized. Run Buidler with --verbose to learn more."));
                this._stackTracesEnabled = false;
                log("Solidity stack traces disabled: SolidityTracer failed to be initialized. Please report this to help us improve Buidler.\n", error);
            }
        }
    }
    static async create(hardfork, networkName, chainId, networkId, blockGasLimit, throwOnTransactionFailures, throwOnCallFailures, genesisAccounts = [], stackTracesOptions) {
        const stateTrie = new secure_1.default();
        const putIntoStateTrie = util_1.promisify(stateTrie.put.bind(stateTrie));
        for (const acc of genesisAccounts) {
            let balance;
            if (typeof acc.balance === "string" &&
                acc.balance.toLowerCase().startsWith("0x")) {
                balance = new ethereumjs_util_1.BN(ethereumjs_util_1.toBuffer(acc.balance));
            }
            else {
                balance = new ethereumjs_util_1.BN(acc.balance);
            }
            const account = new ethereumjs_account_1.default({ balance });
            const pk = ethereumjs_util_1.toBuffer(acc.privateKey);
            const address = ethereumjs_util_1.privateToAddress(pk);
            await putIntoStateTrie(address, account.serialize());
        }
        // Mimic precompiles activation
        for (let i = 1; i <= 8; i++) {
            await putIntoStateTrie(new ethereumjs_util_1.BN(i).toArrayLike(Buffer, "be", 20), new ethereumjs_account_1.default().serialize());
        }
        const common = ethereumjs_common_1.default.forCustomChain("mainnet", {
            chainId,
            networkId,
            name: networkName,
            genesis: {
                timestamp: `0x${utils_1.getCurrentTimestamp().toString(16)}`,
                hash: "0x",
                gasLimit: blockGasLimit,
                difficulty: 1,
                nonce: "0x42",
                extraData: "0x1234",
                stateRoot: ethereumjs_util_1.bufferToHex(stateTrie.root)
            }
        }, hardfork);
        const stateManager = new state_1.StateManager({
            common: common,
            trie: stateTrie
        });
        const blockchain = new blockchain_1.Blockchain();
        const vm = new ethereumjs_vm_1.default({
            common: common,
            activatePrecompiles: true,
            stateManager,
            blockchain: blockchain
        });
        const genesisBlock = new ethereumjs_block_1.default(null, { common });
        genesisBlock.setGenesisParams();
        await new Promise(resolve => {
            blockchain.putBlock(genesisBlock, () => resolve());
        });
        const node = new BuidlerNode(vm, blockchain, genesisAccounts.map(acc => ethereumjs_util_1.toBuffer(acc.privateKey)), new ethereumjs_util_1.BN(blockGasLimit), genesisBlock, throwOnTransactionFailures, throwOnCallFailures, stackTracesOptions);
        return [common, node];
    }
    async getSignedTransaction(txParams) {
        const tx = new ethereumjs_tx_1.Transaction(txParams, { common: this._common });
        const pk = await this._getLocalAccountPrivateKey(txParams.from);
        tx.sign(pk);
        return tx;
    }
    async _getFakeTransaction(txParams) {
        return new ethereumjs_tx_1.FakeTransaction(txParams, { common: this._common });
    }
    async runTransactionInNewBlock(tx) {
        await this._validateTransaction(tx);
        await this._saveTransactionAsReceived(tx);
        const block = await this._getNextBlockTemplate();
        const needsTimestampIncrease = await this._timestampClashesWithPreviousBlockOne(block);
        if (needsTimestampIncrease) {
            await this._increaseBlockTimestamp(block);
        }
        await this._addTransactionToBlock(block, tx);
        const result = await this._vm.runBlock({
            block,
            generate: true,
            skipBlockValidation: true
        });
        await this._printLogs();
        const error = !this._throwOnTransactionFailures
            ? undefined
            : await this._manageErrors(result.results[0].execResult);
        if (needsTimestampIncrease) {
            await this.increaseTime(new ethereumjs_util_1.BN(1));
        }
        await this._saveBlockAsSuccessfullyRun(block, result);
        await this._saveTransactionAsSuccessfullyRun(tx, block);
        if (error !== undefined) {
            throw error;
        }
        return result;
    }
    async mineEmptyBlock() {
        const block = await this._getNextBlockTemplate();
        const needsTimestampIncrease = await this._timestampClashesWithPreviousBlockOne(block);
        if (needsTimestampIncrease) {
            await this._increaseBlockTimestamp(block);
        }
        await util_1.promisify(block.genTxTrie.bind(block))();
        block.header.transactionsTrie = block.txTrie.root;
        const previousRoot = await this._stateManager.getStateRoot();
        let result;
        try {
            result = await this._vm.runBlock({
                block,
                generate: true,
                skipBlockValidation: true
            });
            if (needsTimestampIncrease) {
                await this.increaseTime(new ethereumjs_util_1.BN(1));
            }
            await this._saveBlockAsSuccessfullyRun(block, result);
            return result;
        }
        catch (error) {
            // We set the state root to the previous one. This is equivalent to a
            // rollback of this block.
            await this._stateManager.setStateRoot(previousRoot);
            throw error;
        }
    }
    async runCall(call) {
        const tx = await this._getFakeTransaction(Object.assign({}, call, { nonce: await this.getAccountNonce(call.from) }));
        const result = await this._runTxAndRevertMutations(tx, false, false);
        const error = !this._throwOnCallFailures
            ? undefined
            : await this._manageErrors(result.execResult);
        if (error !== undefined) {
            throw error;
        }
        if (result.execResult.exceptionError === undefined ||
            result.execResult.exceptionError.error === exceptions_1.ERROR.REVERT) {
            return result.execResult.returnValue;
        }
        // If we got here we found another kind of error and we throw anyway
        throw this._manageErrors(result.execResult);
    }
    async getAccountBalance(address) {
        const account = await this._stateManager.getAccount(address);
        return new ethereumjs_util_1.BN(account.balance);
    }
    async getAccountNonce(address) {
        const account = await this._stateManager.getAccount(address);
        return new ethereumjs_util_1.BN(account.nonce);
    }
    async getLatestBlock() {
        return this._getLatestBlock();
    }
    async getLocalAccountAddresses() {
        return [...this._accountPrivateKeys.keys()];
    }
    async getBlockGasLimit() {
        return this._blockGasLimit;
    }
    async estimateGas(txParams) {
        const tx = await this._getFakeTransaction(Object.assign({}, txParams, { gasLimit: await this.getBlockGasLimit() }));
        const result = await this._runTxAndRevertMutations(tx, true, true);
        // This is only considered if the call to _runTxAndRevertMutations doesn't
        // manage errors
        if (result.execResult.exceptionError !== undefined) {
            return this.getBlockGasLimit();
        }
        const initialEstimation = result.gasUsed;
        return this._correctInitialEstimation(txParams, initialEstimation);
    }
    async getGasPrice() {
        return new ethereumjs_util_1.BN(default_config_1.BUIDLEREVM_DEFAULT_GAS_PRICE);
    }
    async getCoinbaseAddress() {
        return exports.COINBASE_ADDRESS;
    }
    async getStorageAt(address, slot) {
        const key = slot.toArrayLike(Buffer, "be", 32);
        const data = await this._stateManager.getContractStorage(address, key);
        // TODO: The state manager returns the data as it was saved, it doesn't
        //  pad it. Technically, the storage consists of 32-byte slots, so we should
        //  always return 32 bytes. The problem is that Ganache doesn't handle them
        //  this way. We compromise a little here to ease the migration into
        //  BuidlerEVM :(
        // const EXPECTED_DATA_SIZE = 32;
        // if (data.length < EXPECTED_DATA_SIZE) {
        //   return Buffer.concat(
        //     [Buffer.alloc(EXPECTED_DATA_SIZE - data.length, 0), data],
        //     EXPECTED_DATA_SIZE
        //   );
        // }
        return data;
    }
    async getBlockByNumber(blockNumber) {
        if (blockNumber.gten(this._blockHashToTotalDifficulty.size)) {
            return undefined;
        }
        return this._getBlock(blockNumber);
    }
    async getBlockByHash(hash) {
        if (!(await this._hasBlockWithHash(hash))) {
            return undefined;
        }
        return this._getBlock(hash);
    }
    async getBlockByTransactionHash(hash) {
        const blockHash = this._transactionHashToBlockHash.get(ethereumjs_util_1.bufferToHex(hash));
        if (blockHash === undefined) {
            return undefined;
        }
        return this.getBlockByHash(ethereumjs_util_1.toBuffer(blockHash));
    }
    async getBlockTotalDifficulty(block) {
        const blockHash = ethereumjs_util_1.bufferToHex(block.hash());
        const td = this._blockHashToTotalDifficulty.get(blockHash);
        if (td !== undefined) {
            return td;
        }
        return this._computeTotalDifficulty(block);
    }
    async getCode(address) {
        return this._stateManager.getContractCode(address);
    }
    async increaseTime(increment) {
        this._blockTimeOffsetSeconds = this._blockTimeOffsetSeconds.add(increment);
    }
    async getTimeIncrement() {
        return this._blockTimeOffsetSeconds;
    }
    async getSuccessfulTransactionByHash(hash) {
        const tx = this._transactionByHash.get(ethereumjs_util_1.bufferToHex(hash));
        if (tx !== undefined && (await this._transactionWasSuccessful(tx))) {
            return tx;
        }
        return undefined;
    }
    async getTxBlockResults(block) {
        return this._blockHashToTxBlockResults.get(ethereumjs_util_1.bufferToHex(block.hash()));
    }
    async getPendingTransactions() {
        return [];
    }
    async signPersonalMessage(address, data) {
        const messageHash = ethereumjs_util_1.hashPersonalMessage(data);
        const privateKey = await this._getLocalAccountPrivateKey(address);
        return ethereumjs_util_1.ecsign(messageHash, privateKey);
    }
    async signTypedData(address, typedData) {
        const privateKey = await this._getLocalAccountPrivateKey(address);
        return ethSigUtil.signTypedData_v4(privateKey, {
            data: typedData
        });
    }
    async getStackTraceFailuresCount() {
        return this._failedStackTraces;
    }
    async takeSnapshot() {
        const id = this._nextSnapshotId;
        // We copy all the maps here, as they may be modified
        const snapshot = {
            id,
            date: new Date(),
            latestBlock: await this.getLatestBlock(),
            stateRoot: await this._stateManager.getStateRoot(),
            blockTimeOffsetSeconds: new ethereumjs_util_1.BN(this._blockTimeOffsetSeconds),
            transactionByHash: new Map(this._transactionByHash.entries()),
            transactionHashToBlockHash: new Map(this._transactionHashToBlockHash.entries()),
            blockHashToTxBlockResults: new Map(this._blockHashToTxBlockResults.entries()),
            blockHashToTotalDifficulty: new Map(this._blockHashToTotalDifficulty.entries()),
            lastFilterId: this._lastFilterId,
            blockFiltersLastBlockSent: new Map(this._blockFiltersLastBlockSent.entries())
        };
        this._snapshots.push(snapshot);
        this._nextSnapshotId += 1;
        return id;
    }
    async revertToSnapshot(id) {
        const snapshotIndex = this._getSnapshotIndex(id);
        if (snapshotIndex === undefined) {
            return false;
        }
        const snapshot = this._snapshots[snapshotIndex];
        // We compute a new offset such that
        //  now + new_offset === snapshot_date + old_offset
        const now = new Date();
        const offsetToSnapshotInMillis = snapshot.date.valueOf() - now.valueOf();
        const offsetToSnapshotInSecs = Math.ceil(offsetToSnapshotInMillis / 1000);
        const newOffset = snapshot.blockTimeOffsetSeconds.addn(offsetToSnapshotInSecs);
        // We delete all following blocks, changes the state root, and all the
        // relevant Node fields.
        //
        // Note: There's no need to copy the maps here, as snapshots can only be
        // used once
        this._blockchain.deleteAllFollowingBlocks(snapshot.latestBlock);
        await this._stateManager.setStateRoot(snapshot.stateRoot);
        this._blockTimeOffsetSeconds = newOffset;
        this._transactionByHash = snapshot.transactionByHash;
        this._transactionHashToBlockHash = snapshot.transactionHashToBlockHash;
        this._blockHashToTxBlockResults = snapshot.blockHashToTxBlockResults;
        this._blockHashToTotalDifficulty = snapshot.blockHashToTotalDifficulty;
        this._lastFilterId = snapshot.lastFilterId;
        this._blockFiltersLastBlockSent = snapshot.blockFiltersLastBlockSent;
        // We delete this and the following snapshots, as they can only be used
        // once in Ganache
        this._snapshots.splice(snapshotIndex);
        return true;
    }
    async createBlockFilter() {
        const filterId = this._lastFilterId + 1;
        const block = await this.getLatestBlock();
        const currentBlockNumber = new ethereumjs_util_1.BN(block.header.number);
        // We always show the last block in the initial getChanges
        const lastBlockSent = currentBlockNumber.subn(1);
        this._blockFiltersLastBlockSent.set(filterId, lastBlockSent);
        this._lastFilterId += 1;
        return filterId;
    }
    async uninstallFilter(filterId) {
        // This should be able to uninstall any kind of filter, not just
        // block filters
        if (this._blockFiltersLastBlockSent.has(filterId)) {
            this._blockFiltersLastBlockSent.delete(filterId);
            return true;
        }
        return false;
    }
    async isBlockFilter(filterId) {
        return this._blockFiltersLastBlockSent.has(filterId);
    }
    async getBlockFilterChanges(filterId) {
        if (!this._blockFiltersLastBlockSent.has(filterId)) {
            return undefined;
        }
        const lastBlockSent = this._blockFiltersLastBlockSent.get(filterId);
        const latestBlock = await this.getLatestBlock();
        const currentBlockNumber = new ethereumjs_util_1.BN(latestBlock.header.number);
        const blockHashes = [];
        let blockNumber;
        for (blockNumber = lastBlockSent.addn(1); blockNumber.lte(currentBlockNumber); blockNumber = blockNumber.addn(1)) {
            const block = await this.getBlockByNumber(blockNumber);
            blockHashes.push(ethereumjs_util_1.bufferToHex(block.header.hash()));
        }
        this._blockFiltersLastBlockSent.set(filterId, blockNumber.subn(1));
        return blockHashes;
    }
    _getSnapshotIndex(id) {
        for (const [i, snapshot] of this._snapshots.entries()) {
            if (snapshot.id === id) {
                return i;
            }
            // We already removed the snapshot we are looking for
            if (snapshot.id > id) {
                return undefined;
            }
        }
        return undefined;
    }
    _initLocalAccounts(localAccounts) {
        for (const pk of localAccounts) {
            this._accountPrivateKeys.set(ethereumjs_util_1.bufferToHex(ethereumjs_util_1.privateToAddress(pk)), pk);
        }
    }
    async _printLogs() {
        try {
            const vmTracerError = this._vmTracer.getLastError();
            // in case stack traces are enabled we dont want to clear last error
            if (vmTracerError !== undefined && !this._stackTracesEnabled) {
                this._vmTracer.clearLastError();
                throw vmTracerError;
            }
            const messageTrace = this._vmTracer.getLastTopLevelMessageTrace();
            this._consoleLogger.printLogs(messageTrace);
        }
        catch (error) {
            log("Could not print console log. Please report this to help us improve Buidler.\n", error);
        }
    }
    async _manageErrors(vmResult) {
        if (vmResult.exceptionError === undefined) {
            return undefined;
        }
        let stackTrace;
        if (this._stackTracesEnabled) {
            try {
                const vmTracerError = this._vmTracer.getLastError();
                if (vmTracerError !== undefined) {
                    this._vmTracer.clearLastError();
                    throw vmTracerError;
                }
                const messageTrace = this._vmTracer.getLastTopLevelMessageTrace();
                const decodedTrace = this._solidityTracer.tryToDecodeMessageTrace(messageTrace);
                stackTrace = this._solidityTracer.getStackTrace(decodedTrace);
            }
            catch (error) {
                this._failedStackTraces += 1;
                log("Could not generate stack trace. Please report this to help us improve Buidler.\n", error);
            }
        }
        const error = vmResult.exceptionError;
        if (error.error === exceptions_1.ERROR.OUT_OF_GAS) {
            return new TransactionExecutionError("Transaction run out of gas");
        }
        if (error.error === exceptions_1.ERROR.REVERT) {
            if (vmResult.returnValue.length === 0) {
                if (stackTrace !== undefined) {
                    return solidity_errors_1.encodeSolidityStackTrace("Transaction reverted without a reason", stackTrace);
                }
                return new TransactionExecutionError("Transaction reverted without a reason");
            }
            if (stackTrace !== undefined) {
                return solidity_errors_1.encodeSolidityStackTrace(`VM Exception while processing transaction: revert ${revert_reasons_1.decodeRevertReason(vmResult.returnValue)}`, stackTrace);
            }
            return new TransactionExecutionError(`VM Exception while processing transaction: revert ${revert_reasons_1.decodeRevertReason(vmResult.returnValue)}`);
        }
        if (stackTrace !== undefined) {
            return solidity_errors_1.encodeSolidityStackTrace("Transaction failed: revert", stackTrace);
        }
        return new TransactionExecutionError("Transaction failed: revert");
    }
    async _getNextBlockTemplate() {
        const block = new ethereumjs_block_1.default({
            header: {
                gasLimit: this._blockGasLimit,
                nonce: "0x42",
                timestamp: await this._getNextBlockTimestamp()
            }
        }, { common: this._common });
        block.validate = (blockchain, cb) => cb(null);
        const latestBlock = await this.getLatestBlock();
        block.header.number = ethereumjs_util_1.toBuffer(new ethereumjs_util_1.BN(latestBlock.header.number).addn(1));
        block.header.parentHash = latestBlock.hash();
        block.header.difficulty = block.header.canonicalDifficulty(latestBlock);
        block.header.coinbase = await this.getCoinbaseAddress();
        return block;
    }
    async _getNextBlockTimestamp() {
        const realTimestamp = new ethereumjs_util_1.BN(utils_1.getCurrentTimestamp());
        return realTimestamp.add(this._blockTimeOffsetSeconds);
    }
    async _saveTransactionAsReceived(tx) {
        this._transactionByHash.set(ethereumjs_util_1.bufferToHex(tx.hash(true)), tx);
    }
    async _getLocalAccountPrivateKey(sender) {
        const senderAddress = ethereumjs_util_1.bufferToHex(sender);
        if (!this._accountPrivateKeys.has(senderAddress)) {
            throw new errors_1.InvalidInputError(`unknown account ${senderAddress}`);
        }
        return this._accountPrivateKeys.get(senderAddress);
    }
    async _addTransactionToBlock(block, tx) {
        block.transactions.push(tx);
        await util_1.promisify(block.genTxTrie.bind(block))();
        block.header.transactionsTrie = block.txTrie.root;
    }
    async _saveBlockAsSuccessfullyRun(block, runBlockResult) {
        await this._putBlock(block);
        const txBlockResults = [];
        for (let i = 0; i < runBlockResult.results.length; i += 1) {
            const result = runBlockResult.results[i];
            txBlockResults.push({
                bloomBitvector: result.bloom.bitvector,
                createAddresses: result.createdAddress,
                receipt: runBlockResult.receipts[i]
            });
        }
        const blockHash = ethereumjs_util_1.bufferToHex(block.hash());
        this._blockHashToTxBlockResults.set(blockHash, txBlockResults);
        const td = this._computeTotalDifficulty(block);
        this._blockHashToTotalDifficulty.set(blockHash, td);
    }
    async _putBlock(block) {
        return new Promise((resolve, reject) => {
            this._vm.blockchain.putBlock(block, (err) => {
                if (err !== undefined && err !== null) {
                    reject(err);
                    return;
                }
                resolve();
            });
        });
    }
    async _hasBlockWithHash(blockHash) {
        if (this._blockHashToTotalDifficulty.has(ethereumjs_util_1.bufferToHex(blockHash))) {
            return true;
        }
        const block = await this.getBlockByNumber(new ethereumjs_util_1.BN(0));
        return block.hash().equals(blockHash);
    }
    async _saveTransactionAsSuccessfullyRun(tx, block) {
        this._transactionHashToBlockHash.set(ethereumjs_util_1.bufferToHex(tx.hash(true)), ethereumjs_util_1.bufferToHex(block.hash()));
    }
    async _transactionWasSuccessful(tx) {
        return this._transactionHashToBlockHash.has(ethereumjs_util_1.bufferToHex(tx.hash(true)));
    }
    async _timestampClashesWithPreviousBlockOne(block) {
        const blockTimestamp = new ethereumjs_util_1.BN(block.header.timestamp);
        const latestBlock = await this.getLatestBlock();
        const latestBlockTimestamp = new ethereumjs_util_1.BN(latestBlock.header.timestamp);
        return latestBlockTimestamp.eq(blockTimestamp);
    }
    async _increaseBlockTimestamp(block) {
        block.header.timestamp = new ethereumjs_util_1.BN(block.header.timestamp).addn(1);
    }
    async _validateTransaction(tx) {
        // Geth throws this error if a tx is sent twice
        if (await this._transactionWasSuccessful(tx)) {
            throw new errors_1.InvalidInputError(`known transaction: ${ethereumjs_util_1.bufferToHex(tx.hash(true)).toString()}`);
        }
        if (!tx.verifySignature()) {
            throw new errors_1.InvalidInputError("Invalid transaction signature");
        }
        // Geth returns this error if trying to create a contract and no data is provided
        if (tx.to.length === 0 && tx.data.length === 0) {
            throw new errors_1.InvalidInputError("contract creation without any data provided");
        }
        const expectedNonce = await this.getAccountNonce(tx.getSenderAddress());
        const actualNonce = new ethereumjs_util_1.BN(tx.nonce);
        if (!expectedNonce.eq(actualNonce)) {
            throw new errors_1.InvalidInputError(`Invalid nonce. Expected ${expectedNonce} but got ${actualNonce}`);
        }
        const baseFee = tx.getBaseFee();
        const gasLimit = new ethereumjs_util_1.BN(tx.gasLimit);
        if (baseFee.gt(gasLimit)) {
            throw new errors_1.InvalidInputError(`Transaction requires at least ${baseFee} gas but got ${gasLimit}`);
        }
        if (gasLimit.gt(this._blockGasLimit)) {
            throw new errors_1.InvalidInputError(`Transaction gas limit is ${gasLimit} and exceeds block gas limit of ${this._blockGasLimit}`);
        }
    }
    _computeTotalDifficulty(block) {
        const difficulty = new ethereumjs_util_1.BN(block.header.difficulty);
        const parentHash = ethereumjs_util_1.bufferToHex(block.header.parentHash);
        if (parentHash ===
            "0x0000000000000000000000000000000000000000000000000000000000000000") {
            return difficulty;
        }
        const parentTd = this._blockHashToTotalDifficulty.get(parentHash);
        if (parentTd === undefined) {
            throw new errors_1.InternalError(`Unrecognized parent block ${parentHash}`);
        }
        return parentTd.add(difficulty);
    }
    async _correctInitialEstimation(txParams, initialEstimation) {
        let tx = await this._getFakeTransaction(Object.assign({}, txParams, { gasLimit: initialEstimation }));
        if (tx.getBaseFee().gte(initialEstimation)) {
            initialEstimation = tx.getBaseFee().addn(1);
            tx = await this._getFakeTransaction(Object.assign({}, txParams, { gasLimit: initialEstimation }));
        }
        const result = await this._runTxAndRevertMutations(tx, false, true);
        if (result.execResult.exceptionError === undefined) {
            return initialEstimation;
        }
        return this._binarySearchEstimation(txParams, initialEstimation, await this.getBlockGasLimit());
    }
    async _binarySearchEstimation(txParams, highestFailingEstimation, lowestSuccessfulEstimation, roundNumber = 0) {
        if (lowestSuccessfulEstimation.lte(highestFailingEstimation)) {
            // This shouldn't happen, but we don't wan't to go into an infinite loop
            // if it ever happens
            return lowestSuccessfulEstimation;
        }
        const MAX_GAS_ESTIMATION_IMPROVEMENT_ROUNDS = 20;
        const diff = lowestSuccessfulEstimation.sub(highestFailingEstimation);
        const minDiff = highestFailingEstimation.gten(4000000)
            ? 50000
            : highestFailingEstimation.gten(1000000)
                ? 10000
                : highestFailingEstimation.gten(100000)
                    ? 1000
                    : highestFailingEstimation.gten(50000)
                        ? 500
                        : highestFailingEstimation.gten(30000)
                            ? 300
                            : 200;
        if (diff.lten(minDiff)) {
            return lowestSuccessfulEstimation;
        }
        if (roundNumber > MAX_GAS_ESTIMATION_IMPROVEMENT_ROUNDS) {
            return lowestSuccessfulEstimation;
        }
        const binSearchNewEstimation = highestFailingEstimation.add(diff.divn(2));
        const optimizedEstimation = roundNumber === 0
            ? highestFailingEstimation.muln(3)
            : binSearchNewEstimation;
        const newEstimation = optimizedEstimation.gt(binSearchNewEstimation)
            ? binSearchNewEstimation
            : optimizedEstimation;
        // Let other things execute
        await new Promise(resolve => setImmediate(resolve));
        const tx = await this._getFakeTransaction(Object.assign({}, txParams, { gasLimit: newEstimation }));
        const result = await this._runTxAndRevertMutations(tx, false, true);
        if (result.execResult.exceptionError === undefined) {
            return this._binarySearchEstimation(txParams, highestFailingEstimation, newEstimation, roundNumber + 1);
        }
        return this._binarySearchEstimation(txParams, newEstimation, lowestSuccessfulEstimation, roundNumber + 1);
    }
    async _runTxAndRevertMutations(tx, manageErrors = true, estimateGas = false) {
        const initialStateRoot = await this._stateManager.getStateRoot();
        try {
            const block = await this._getNextBlockTemplate();
            const needsTimestampIncrease = await this._timestampClashesWithPreviousBlockOne(block);
            if (needsTimestampIncrease) {
                await this._increaseBlockTimestamp(block);
            }
            await this._addTransactionToBlock(block, tx);
            const result = await this._vm.runTx({
                block,
                tx,
                skipNonce: true,
                skipBalance: true
            });
            if (!estimateGas) {
                await this._printLogs();
            }
            if (manageErrors) {
                const error = await this._manageErrors(result.execResult);
                if (error !== undefined) {
                    throw error;
                }
            }
            return result;
        }
        finally {
            await this._stateManager.setStateRoot(initialStateRoot);
        }
    }
}
exports.BuidlerNode = BuidlerNode;
//# sourceMappingURL=node.js.map