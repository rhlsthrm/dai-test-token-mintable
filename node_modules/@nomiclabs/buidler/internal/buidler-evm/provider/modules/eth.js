"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const ethereumjs_tx_1 = require("ethereumjs-tx");
const ethereumjs_util_1 = require("ethereumjs-util");
const t = __importStar(require("io-ts"));
const errors_1 = require("../errors");
const input_1 = require("../input");
const output_1 = require("../output");
// tslint:disable only-buidler-error
class EthModule {
    constructor(_common, _node) {
        this._common = _common;
        this._node = _node;
    }
    async processRequest(method, params = []) {
        switch (method) {
            case "eth_accounts":
                return this._accountsAction(...this._accountsParams(params));
            case "eth_blockNumber":
                return this._blockNumberAction(...this._blockNumberParams(params));
            case "eth_call":
                return this._callAction(...this._callParams(params));
            case "eth_chainId":
                return this._chainIdAction(...this._chainIdParams(params));
            case "eth_coinbase":
                return this._coinbaseAction(...this._coinbaseParams(params));
            case "eth_compileLLL":
                throw new errors_1.MethodNotSupportedError(`Method ${method} is not supported`);
            case "eth_compileSerpent":
                throw new errors_1.MethodNotSupportedError(`Method ${method} is not supported`);
            case "eth_compileSolidity":
                throw new errors_1.MethodNotSupportedError(`Method ${method} is not supported`);
            case "eth_estimateGas":
                return this._estimateGasAction(...this._estimateGasParams(params));
            case "eth_gasPrice":
                return this._gasPriceAction(...this._gasPriceParams(params));
            case "eth_getBalance":
                return this._getBalanceAction(...this._getBalanceParams(params));
            case "eth_getBlockByHash":
                return this._getBlockByHashAction(...this._getBlockByHashParams(params));
            case "eth_getBlockByNumber":
                return this._getBlockByNumberAction(...this._getBlockByNumberParams(params));
            case "eth_getBlockTransactionCountByHash":
                return this._getBlockTransactionCountByHashAction(...this._getBlockTransactionCountByHashParams(params));
            case "eth_getBlockTransactionCountByNumber":
                return this._getBlockTransactionCountByNumberAction(...this._getBlockTransactionCountByNumberParams(params));
            case "eth_getCode":
                return this._getCodeAction(...this._getCodeParams(params));
            case "eth_getCompilers":
                throw new errors_1.MethodNotSupportedError(`Method ${method} is not supported`);
            case "eth_getFilterChanges":
                return this._getFilterChangesAction(...this._getFilterChangesParams(params));
            case "eth_getFilterLogs":
                throw new errors_1.MethodNotSupportedError(`Method ${method} is not supported`);
            case "eth_getLogs":
                throw new errors_1.MethodNotSupportedError(`Method ${method} is not supported`);
            case "eth_getProof":
                throw new errors_1.MethodNotSupportedError(`Method ${method} is not supported`);
            case "eth_getStorageAt":
                return this._getStorageAtAction(...this._getStorageAtParams(params));
            case "eth_getTransactionByBlockHashAndIndex":
                return this._getTransactionByBlockHashAndIndexAction(...this._getTransactionByBlockHashAndIndexParams(params));
            case "eth_getTransactionByBlockNumberAndIndex":
                return this._getTransactionByBlockNumberAndIndexAction(...this._getTransactionByBlockNumberAndIndexParams(params));
            case "eth_getTransactionByHash":
                return this._getTransactionByHashAction(...this._getTransactionByHashParams(params));
            case "eth_getTransactionCount":
                return this._getTransactionCountAction(...this._getTransactionCountParams(params));
            case "eth_getTransactionReceipt":
                return this._getTransactionReceiptAction(...this._getTransactionReceiptParams(params));
            case "eth_getUncleByBlockHashAndIndex":
                throw new errors_1.MethodNotSupportedError(`Method ${method} is not supported`);
            case "eth_getUncleByBlockNumberAndIndex":
                throw new errors_1.MethodNotSupportedError(`Method ${method} is not supported`);
            case "eth_getUncleCountByBlockHash":
                throw new errors_1.MethodNotSupportedError(`Method ${method} is not supported`);
            case "eth_getUncleCountByBlockNumber":
                throw new errors_1.MethodNotSupportedError(`Method ${method} is not supported`);
            case "eth_getWork":
                throw new errors_1.MethodNotSupportedError(`Method ${method} is not supported`);
            case "eth_hashrate":
                throw new errors_1.MethodNotSupportedError(`Method ${method} is not supported`);
            case "eth_mining":
                return this._miningAction(...this._miningParams(params));
            case "eth_newBlockFilter":
                return this._newBlockFilterAction(...this._newBlockFilterParams(params));
            case "eth_newFilter":
                throw new errors_1.MethodNotSupportedError(`Method ${method} is not supported`);
            case "eth_newPendingTransactionFilter":
                throw new errors_1.MethodNotSupportedError(`Method ${method} is not supported`);
            case "eth_pendingTransactions":
                return this._pendingTransactionsAction(...this._pendingTransactionsParams(params));
            case "eth_protocolVersion":
                throw new errors_1.MethodNotSupportedError(`Method ${method} is not supported`);
            case "eth_sendRawTransaction":
                return this._sendRawTransactionAction(...this._sendRawTransactionParams(params));
            case "eth_sendTransaction":
                return this._sendTransactionAction(...this._sendTransactionParams(params));
            case "eth_sign":
                return this._signAction(...this._signParams(params));
            case "eth_signTransaction":
                throw new errors_1.MethodNotSupportedError(`Method ${method} is not supported`);
            case "eth_signTypedData":
                return this._signTypedDataAction(...this._signTypedDataParams(params));
            case "eth_submitHashrate":
                throw new errors_1.MethodNotSupportedError(`Method ${method} is not supported`);
            case "eth_submitWork":
                throw new errors_1.MethodNotSupportedError(`Method ${method} is not supported`);
            case "eth_subscribe":
                throw new errors_1.MethodNotSupportedError(`Method ${method} is not supported`);
            case "eth_syncing":
                return this._syncingAction(...this._syncingParams(params));
            case "eth_uninstallFilter":
                return this._uninstallFilterAction(...this._uninstallFilterParams(params));
            case "eth_unsubscribe":
                throw new errors_1.MethodNotSupportedError(`Method ${method} is not supported`);
        }
        throw new errors_1.MethodNotFoundError(`Method ${method} not found`);
    }
    // eth_accounts
    _accountsParams(params) {
        return input_1.validateParams(params);
    }
    async _accountsAction() {
        return this._node.getLocalAccountAddresses();
    }
    // eth_blockNumber
    _blockNumberParams(params) {
        return input_1.validateParams(params);
    }
    async _blockNumberAction() {
        const block = await this._node.getLatestBlock();
        const blockNumber = new ethereumjs_util_1.BN(block.header.number);
        return output_1.numberToRpcQuantity(blockNumber);
    }
    // eth_call
    _callParams(params) {
        return input_1.validateParams(params, input_1.rpcCallRequest, input_1.optionalBlockTag);
    }
    async _callAction(rpcCall, blockTag) {
        this._validateBlockTag(blockTag);
        const callParams = await this._rpcCallRequestToNodeCallParams(rpcCall);
        const returnData = await this._node.runCall(callParams);
        return output_1.bufferToRpcData(returnData);
    }
    // eth_chainId
    _chainIdParams(params) {
        return input_1.validateParams(params);
    }
    async _chainIdAction() {
        return output_1.numberToRpcQuantity(this._common.chainId());
    }
    // eth_coinbase
    _coinbaseParams(params) {
        return input_1.validateParams(params);
    }
    async _coinbaseAction() {
        return ethereumjs_util_1.bufferToHex(await this._node.getCoinbaseAddress());
    }
    // eth_compileLLL
    // eth_compileSerpent
    // eth_compileSolidity
    // eth_estimateGas
    _estimateGasParams(params) {
        return input_1.validateParams(params, input_1.rpcTransactionRequest, input_1.optionalBlockTag);
    }
    async _estimateGasAction(transactionRequest, blockTag) {
        this._validateBlockTag(blockTag);
        const txParams = await this._rpcTransactionRequestToNodeTransactionParams(transactionRequest);
        return output_1.numberToRpcQuantity(await this._node.estimateGas(txParams));
    }
    // eth_gasPrice
    _gasPriceParams(params) {
        return input_1.validateParams(params);
    }
    async _gasPriceAction() {
        return output_1.numberToRpcQuantity(await this._node.getGasPrice());
    }
    // eth_getBalance
    _getBalanceParams(params) {
        return input_1.validateParams(params, input_1.rpcAddress, input_1.optionalBlockTag);
    }
    async _getBalanceAction(address, blockTag) {
        this._validateBlockTag(blockTag);
        return output_1.numberToRpcQuantity(await this._node.getAccountBalance(address));
    }
    // eth_getBlockByHash
    _getBlockByHashParams(params) {
        return input_1.validateParams(params, input_1.rpcHash, t.boolean);
    }
    async _getBlockByHashAction(hash, includeTransactions) {
        const block = await this._node.getBlockByHash(hash);
        if (block === undefined) {
            return null;
        }
        const totalDifficulty = await this._node.getBlockTotalDifficulty(block);
        return output_1.getRpcBlock(block, totalDifficulty, includeTransactions);
    }
    // eth_getBlockByNumber
    _getBlockByNumberParams(params) {
        return input_1.validateParams(params, input_1.optionalBlockTag, t.boolean);
    }
    async _getBlockByNumberAction(tag, includeTransactions) {
        let block;
        if (typeof tag === "string") {
            if (tag === "earliest" || tag === "pending") {
                throw new errors_1.InvalidInputError("eth_getBlockByNumber doesn't support earliest nor pending ");
            }
            block = await this._node.getLatestBlock();
        }
        else {
            // The tag can't be undefined because the includeTransactions param is
            // required.
            // TODO: Make this more explicit
            block = await this._node.getBlockByNumber(tag);
        }
        if (block === undefined) {
            return null;
        }
        const totalDifficulty = await this._node.getBlockTotalDifficulty(block);
        return output_1.getRpcBlock(block, totalDifficulty, includeTransactions);
    }
    // eth_getBlockTransactionCountByHash
    _getBlockTransactionCountByHashParams(params) {
        return input_1.validateParams(params, input_1.rpcHash);
    }
    async _getBlockTransactionCountByHashAction(hash) {
        const block = await this._node.getBlockByHash(hash);
        if (block === undefined) {
            return null;
        }
        return output_1.numberToRpcQuantity(block.transactions.length);
    }
    // eth_getBlockTransactionCountByNumber
    _getBlockTransactionCountByNumberParams(params) {
        return input_1.validateParams(params, input_1.rpcQuantity);
    }
    async _getBlockTransactionCountByNumberAction(blockNumber) {
        const block = await this._node.getBlockByNumber(blockNumber);
        if (block === undefined) {
            return null;
        }
        return output_1.numberToRpcQuantity(block.transactions.length);
    }
    // eth_getCode
    _getCodeParams(params) {
        return input_1.validateParams(params, input_1.rpcAddress, input_1.optionalBlockTag);
    }
    async _getCodeAction(address, blockTag) {
        this._validateBlockTag(blockTag);
        return output_1.bufferToRpcData(await this._node.getCode(address));
    }
    // eth_getCompilers
    // eth_getFilterChanges
    _getFilterChangesParams(params) {
        return input_1.validateParams(params, input_1.rpcQuantity);
    }
    async _getFilterChangesAction(filterId) {
        const id = filterId.toNumber(); // This may throw, but it's ok
        if (await this._node.isBlockFilter(id)) {
            const blockHashes = await this._node.getBlockFilterChanges(id);
            if (blockHashes === undefined) {
                return null;
            }
            return blockHashes;
        }
        // This should return changes for the other filter types
        return null;
    }
    // eth_getFilterLogs
    // eth_getLogs
    // eth_getProof
    // eth_getStorageAt
    _getStorageAtParams(params) {
        return input_1.validateParams(params, input_1.rpcAddress, input_1.rpcQuantity, input_1.optionalBlockTag);
    }
    async _getStorageAtAction(address, slot, blockTag) {
        this._validateBlockTag(blockTag);
        const data = await this._node.getStorageAt(address, slot);
        // data should always be 32 bytes, but we are imitating Ganache here.
        // Please read the comment in `getStorageAt`.
        if (data.length === 0) {
            return "0x0";
        }
        return output_1.bufferToRpcData(data);
    }
    // eth_getTransactionByBlockHashAndIndex
    _getTransactionByBlockHashAndIndexParams(params) {
        return input_1.validateParams(params, input_1.rpcHash, input_1.rpcQuantity);
    }
    async _getTransactionByBlockHashAndIndexAction(hash, index) {
        const i = index.toNumber();
        const block = await this._node.getBlockByHash(hash);
        if (block === undefined) {
            return null;
        }
        const tx = block.transactions[i];
        if (tx === undefined) {
            return null;
        }
        return output_1.getRpcTransaction(tx, block, i);
    }
    // eth_getTransactionByBlockNumberAndIndex
    _getTransactionByBlockNumberAndIndexParams(params) {
        return input_1.validateParams(params, input_1.rpcQuantity, input_1.rpcQuantity);
    }
    async _getTransactionByBlockNumberAndIndexAction(blockNumber, index) {
        const i = index.toNumber();
        const block = await this._node.getBlockByNumber(blockNumber);
        if (block === undefined) {
            return null;
        }
        const tx = block.transactions[i];
        if (tx === undefined) {
            return null;
        }
        return output_1.getRpcTransaction(tx, block, i);
    }
    // eth_getTransactionByHash
    _getTransactionByHashParams(params) {
        return input_1.validateParams(params, input_1.rpcHash);
    }
    async _getTransactionByHashAction(hash) {
        const tx = await this._node.getSuccessfulTransactionByHash(hash);
        if (tx === undefined) {
            return null;
        }
        const block = await this._node.getBlockByTransactionHash(hash);
        let index;
        if (block !== undefined) {
            const transactions = block.transactions;
            const i = transactions.findIndex(bt => bt.hash().equals(hash));
            if (i !== -1) {
                index = i;
            }
        }
        return output_1.getRpcTransaction(tx, block, index);
    }
    // eth_getTransactionCount
    _getTransactionCountParams(params) {
        return input_1.validateParams(params, input_1.rpcAddress, input_1.optionalBlockTag);
    }
    async _getTransactionCountAction(address, blockTag) {
        this._validateBlockTag(blockTag);
        return output_1.numberToRpcQuantity(await this._node.getAccountNonce(address));
    }
    // eth_getTransactionReceipt
    _getTransactionReceiptParams(params) {
        return input_1.validateParams(params, input_1.rpcHash);
    }
    async _getTransactionReceiptAction(hash) {
        // We do not return receipts for failed transactions
        const tx = await this._node.getSuccessfulTransactionByHash(hash);
        if (tx === undefined) {
            return null;
        }
        const block = (await this._node.getBlockByTransactionHash(hash));
        const transactions = block.transactions;
        const index = transactions.findIndex(bt => bt.hash().equals(hash));
        const txBlockResults = await this._node.getTxBlockResults(block);
        return output_1.getRpcTransactionReceipt(tx, block, index, txBlockResults);
    }
    // eth_getUncleByBlockHashAndIndex
    // TODO: Implement
    // eth_getUncleByBlockNumberAndIndex
    // TODO: Implement
    // eth_getUncleCountByBlockHash
    // TODO: Implement
    // eth_getUncleCountByBlockNumber
    // TODO: Implement
    // eth_getWork
    // eth_hashrate
    // eth_mining
    _miningParams(params) {
        return input_1.validateParams(params);
    }
    async _miningAction() {
        return false;
    }
    // eth_newBlockFilter
    _newBlockFilterParams(params) {
        return [];
    }
    async _newBlockFilterAction() {
        const filterId = await this._node.createBlockFilter();
        return output_1.numberToRpcQuantity(filterId);
    }
    // eth_newFilter
    // eth_newPendingTransactionFilter
    // eth_pendingTransactions
    _pendingTransactionsParams(params) {
        return [];
    }
    async _pendingTransactionsAction() {
        const txs = await this._node.getPendingTransactions();
        return txs.map(tx => output_1.getRpcTransaction(tx));
    }
    // eth_protocolVersion
    // eth_sendRawTransaction
    _sendRawTransactionParams(params) {
        return input_1.validateParams(params, input_1.rpcData);
    }
    async _sendRawTransactionAction(rawTx) {
        let tx;
        try {
            tx = new ethereumjs_tx_1.Transaction(rawTx, { common: this._common });
        }
        catch (error) {
            if (error.message === "invalid remainder") {
                throw new errors_1.InvalidInputError("Invalid transaction");
            }
            if (error.message.includes("EIP155")) {
                throw new errors_1.InvalidInputError(error.message);
            }
            throw error;
        }
        await this._node.runTransactionInNewBlock(tx);
        return output_1.bufferToRpcData(tx.hash(true));
    }
    // eth_sendTransaction
    _sendTransactionParams(params) {
        return input_1.validateParams(params, input_1.rpcTransactionRequest);
    }
    async _sendTransactionAction(transactionRequest) {
        const txParams = await this._rpcTransactionRequestToNodeTransactionParams(transactionRequest);
        const tx = await this._node.getSignedTransaction(txParams);
        await this._node.runTransactionInNewBlock(tx);
        return output_1.bufferToRpcData(tx.hash(true));
    }
    // eth_sign
    _signParams(params) {
        return input_1.validateParams(params, input_1.rpcAddress, input_1.rpcData);
    }
    async _signAction(address, data) {
        const signature = await this._node.signPersonalMessage(address, data);
        return ethereumjs_util_1.toRpcSig(signature.v, signature.r, signature.s);
    }
    // eth_signTransaction
    // eth_signTypedData
    _signTypedDataParams(params) {
        return input_1.validateParams(params, input_1.rpcAddress, input_1.rpcUnknown);
    }
    async _signTypedDataAction(address, typedData) {
        return this._node.signTypedData(address, typedData);
    }
    // eth_submitHashrate
    // eth_submitWork
    // eth_subscribe
    // eth_syncing
    _syncingParams(params) {
        return input_1.validateParams(params);
    }
    async _syncingAction() {
        return false;
    }
    // eth_uninstallFilter
    _uninstallFilterParams(params) {
        return input_1.validateParams(params, input_1.rpcQuantity);
    }
    async _uninstallFilterAction(filterId) {
        // NOTE: This will throw if the filter id is too large for a number, but
        // we don't care
        return this._node.uninstallFilter(filterId.toNumber());
    }
    // eth_unsubscribe
    // Utility methods
    async _rpcCallRequestToNodeCallParams(rpcCall) {
        return {
            to: rpcCall.to !== undefined ? rpcCall.to : Buffer.from([]),
            from: rpcCall.from !== undefined
                ? rpcCall.from
                : await this._getDefaultCallFrom(),
            data: rpcCall.data !== undefined ? rpcCall.data : ethereumjs_util_1.toBuffer([]),
            gasLimit: rpcCall.gas !== undefined
                ? rpcCall.gas
                : await this._node.getBlockGasLimit(),
            gasPrice: rpcCall.gasPrice !== undefined
                ? rpcCall.gasPrice
                : await this._node.getGasPrice(),
            value: rpcCall.value !== undefined ? rpcCall.value : new ethereumjs_util_1.BN(0)
        };
    }
    async _rpcTransactionRequestToNodeTransactionParams(rpcTx) {
        return {
            to: rpcTx.to !== undefined ? rpcTx.to : Buffer.from([]),
            from: rpcTx.from,
            gasLimit: rpcTx.gas !== undefined
                ? rpcTx.gas
                : await this._node.getBlockGasLimit(),
            gasPrice: rpcTx.gasPrice !== undefined
                ? rpcTx.gasPrice
                : await this._node.getGasPrice(),
            value: rpcTx.value !== undefined ? rpcTx.value : new ethereumjs_util_1.BN(0),
            data: rpcTx.data !== undefined ? rpcTx.data : ethereumjs_util_1.toBuffer([]),
            nonce: rpcTx.nonce !== undefined
                ? rpcTx.nonce
                : await this._node.getAccountNonce(rpcTx.from)
        };
    }
    _validateBlockTag(blockTag) {
        // We only support latest and pending. As this provider doesn't have pending transactions, its
        // actually just latest.
        if (blockTag !== undefined &&
            blockTag !== "latest" &&
            blockTag !== "pending") {
            throw new errors_1.InvalidInputError("Only latest and pending block params are supported");
        }
    }
    async _getDefaultCallFrom() {
        const localAccounts = await this._node.getLocalAccountAddresses();
        if (localAccounts.length === 0) {
            return ethereumjs_util_1.toBuffer(ethereumjs_util_1.zeroAddress());
        }
        return ethereumjs_util_1.toBuffer(localAccounts[0]);
    }
}
exports.EthModule = EthModule;
//# sourceMappingURL=eth.js.map