"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const chalk_1 = __importDefault(require("chalk"));
const debug_1 = __importDefault(require("debug"));
const events_1 = require("events");
const fs_extra_1 = __importDefault(require("fs-extra"));
const path_1 = __importDefault(require("path"));
const semver_1 = __importDefault(require("semver"));
const constants_1 = require("../../constants");
const project_structure_1 = require("../../core/project-structure");
const solidityTracer_1 = require("../stack-traces/solidityTracer");
const await_semaphore_1 = require("../vendor/await-semaphore");
const errors_1 = require("./errors");
const buidler_1 = require("./modules/buidler");
const eth_1 = require("./modules/eth");
const evm_1 = require("./modules/evm");
const net_1 = require("./modules/net");
const web3_1 = require("./modules/web3");
const node_1 = require("./node");
const log = debug_1.default("buidler:core:buidler-evm:provider");
// tslint:disable only-buidler-error
class BuidlerEVMProvider extends events_1.EventEmitter {
    constructor(_hardfork, _networkName, _chainId, _networkId, _blockGasLimit, _throwOnTransactionFailures, _throwOnCallFailures, _genesisAccounts = [], _solcVersion, _paths) {
        super();
        this._hardfork = _hardfork;
        this._networkName = _networkName;
        this._chainId = _chainId;
        this._networkId = _networkId;
        this._blockGasLimit = _blockGasLimit;
        this._throwOnTransactionFailures = _throwOnTransactionFailures;
        this._throwOnCallFailures = _throwOnCallFailures;
        this._genesisAccounts = _genesisAccounts;
        this._solcVersion = _solcVersion;
        this._paths = _paths;
        this._mutex = new await_semaphore_1.Mutex();
        const config = project_structure_1.getUserConfigPath();
    }
    async send(method, params = []) {
        const release = await this._mutex.acquire();
        try {
            return await this._send(method, params);
        }
        finally {
            release();
        }
    }
    async _sendDebug(method, params = []) {
        try {
            console.log(chalk_1.default.green(`RPC CALL ${method}`), params);
            const res = await this._send(method, params);
            console.log(chalk_1.default.green(`Response of ${method}`), res);
            return res;
        }
        catch (err) {
            console.error(chalk_1.default.red(`Error running ${method}`), err);
            throw err;
        }
    }
    async _send(method, params = []) {
        await this._init();
        if (method.startsWith("eth_")) {
            return this._ethModule.processRequest(method, params);
        }
        if (method.startsWith("net_")) {
            return this._netModule.processRequest(method, params);
        }
        if (method.startsWith("web3_")) {
            return this._web3Module.processRequest(method, params);
        }
        if (method.startsWith("evm_")) {
            return this._evmModule.processRequest(method, params);
        }
        if (method.startsWith("buidler_")) {
            return this._buidlerModule.processRequest(method, params);
        }
        throw new errors_1.MethodNotFoundError(`Method ${method} not found`);
    }
    async _init() {
        if (this._node !== undefined) {
            return;
        }
        let stackTracesOptions;
        if (this._solcVersion !== undefined && this._paths !== undefined) {
            if (semver_1.default.lt(this._solcVersion, solidityTracer_1.FIRST_SOLC_VERSION_SUPPORTED)) {
                console.warn(chalk_1.default.yellow(`Solidity stack traces only work with Solidity version ${solidityTracer_1.FIRST_SOLC_VERSION_SUPPORTED} or higher.`));
            }
            else {
                let hasCompiledContracts = false;
                if (await fs_extra_1.default.pathExists(this._paths.artifacts)) {
                    const artifactsDir = await fs_extra_1.default.readdir(this._paths.artifacts);
                    hasCompiledContracts = artifactsDir.some(f => f.endsWith(".json"));
                }
                if (hasCompiledContracts) {
                    try {
                        const solcInputPath = path_1.default.join(this._paths.cache, constants_1.SOLC_INPUT_FILENAME);
                        const solcOutputPath = path_1.default.join(this._paths.cache, constants_1.SOLC_OUTPUT_FILENAME);
                        stackTracesOptions = {
                            solidityVersion: this._solcVersion,
                            compilerInput: await fs_extra_1.default.readJSON(solcInputPath, {
                                encoding: "utf8"
                            }),
                            compilerOutput: await fs_extra_1.default.readJSON(solcOutputPath, {
                                encoding: "utf8"
                            })
                        };
                    }
                    catch (error) {
                        console.warn(chalk_1.default.yellow("Stack traces engine could not be initialized. Run Buidler with --verbose to learn more."));
                        log("Solidity stack traces disabled: Failed to read solc's input and output files. Please report this to help us improve Buidler.\n", error);
                    }
                }
            }
        }
        const [common, node] = await node_1.BuidlerNode.create(this._hardfork, this._networkName, this._chainId, this._networkId, this._blockGasLimit, this._throwOnTransactionFailures, this._throwOnCallFailures, this._genesisAccounts, stackTracesOptions);
        this._common = common;
        this._node = node;
        this._ethModule = new eth_1.EthModule(common, node);
        this._netModule = new net_1.NetModule(common);
        this._web3Module = new web3_1.Web3Module();
        this._evmModule = new evm_1.EvmModule(node);
        this._buidlerModule = new buidler_1.BuidlerModule(node);
    }
}
exports.BuidlerEVMProvider = BuidlerEVMProvider;
//# sourceMappingURL=provider.js.map