"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const model_1 = require("./model");
const opcodes_1 = require("./opcodes");
function jumpLetterToJumpType(letter) {
    if (letter === "i") {
        return model_1.JumpType.INTO_FUNCTION;
    }
    if (letter === "o") {
        return model_1.JumpType.OUTOF_FUNCTION;
    }
    return model_1.JumpType.NOT_JUMP;
}
function uncompressSourcemaps(compressedSourcemap) {
    const mappings = [];
    const compressedMappings = compressedSourcemap.split(";");
    for (let i = 0; i < compressedMappings.length; i++) {
        const parts = compressedMappings[i].split(":");
        mappings.push({
            location: {
                offset: parts[0] !== undefined && parts[0] !== ""
                    ? +parts[0]
                    : mappings[i - 1].location.offset,
                length: parts[1] !== undefined && parts[1] !== ""
                    ? +parts[1]
                    : mappings[i - 1].location.length,
                file: parts[2] !== undefined && parts[2] !== ""
                    ? +parts[2]
                    : mappings[i - 1].location.file
            },
            jumpType: parts[3] !== undefined && parts[3] !== ""
                ? jumpLetterToJumpType(parts[3])
                : mappings[i - 1].jumpType
        });
    }
    return mappings;
}
function decodeInstructions(bytecode, compressedSourcemaps, fileIdToSourceFile) {
    const sourceMaps = uncompressSourcemaps(compressedSourcemaps);
    const instructions = [];
    let bytesIndex = 0;
    // Solidity inlines some data after the contract, so we stop decoding
    // as soon as we have enough instructions as uncompressed mappings. This is
    // not very documented, but we manually tested that it works.
    while (instructions.length < sourceMaps.length) {
        const pc = bytesIndex;
        const opcode = bytecode[pc];
        const sourceMap = sourceMaps[instructions.length];
        let pushData;
        let location;
        const jumpType = opcodes_1.isJump(opcode) && sourceMap.jumpType === model_1.JumpType.NOT_JUMP
            ? model_1.JumpType.INTERNAL_JUMP
            : sourceMap.jumpType;
        if (opcodes_1.isPush(opcode)) {
            const length = opcodes_1.getPushLength(opcode);
            pushData = bytecode.slice(bytesIndex + 1, bytesIndex + 1 + length);
        }
        if (sourceMap.location.file !== -1) {
            const file = fileIdToSourceFile.get(sourceMap.location.file);
            location = new model_1.SourceLocation(file, sourceMap.location.offset, sourceMap.location.length);
        }
        const instruction = new model_1.Instruction(pc, opcode, jumpType, pushData, location);
        instructions.push(instruction);
        bytesIndex += opcodes_1.getOpcodeLength(opcode);
    }
    return instructions;
}
exports.decodeInstructions = decodeInstructions;
//# sourceMappingURL=source-maps.js.map