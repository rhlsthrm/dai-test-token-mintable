"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const debug_1 = __importDefault(require("debug"));
const lazy_1 = require("../util/lazy");
const errors_1 = require("./errors");
const errors_list_1 = require("./errors-list");
const construction_1 = require("./providers/construction");
const task_definitions_1 = require("./tasks/task-definitions");
const log = debug_1.default("buidler:core:bre");
class Environment {
    /**
     * Initializes the Buidler Runtime Environment and the given
     * extender functions.
     *
     * @remarks The extenders' execution order is given by the order
     * of the requires in the buidler's config file and its plugins.
     *
     * @param config The buidler's config object.
     * @param buidlerArguments The parsed buidler's arguments.
     * @param tasks A map of tasks.
     * @param extenders A list of extenders.
     */
    constructor(config, buidlerArguments, tasks, extenders = []) {
        this.config = config;
        this.buidlerArguments = buidlerArguments;
        this.tasks = tasks;
        /**
         * Executes the task with the given name.
         *
         * @param name The task's name.
         * @param taskArguments A map of task's arguments.
         *
         * @throws a BDLR303 if there aren't any defined tasks with the given name.
         * @returns a promise with the task's execution result.
         */
        this.run = async (name, taskArguments = {}) => {
            const taskDefinition = this.tasks[name];
            log("Running task %s", name);
            if (taskDefinition === undefined) {
                throw new errors_1.BuidlerError(errors_list_1.ERRORS.ARGUMENTS.UNRECOGNIZED_TASK, {
                    task: name
                });
            }
            return this._runTaskDefinition(taskDefinition, taskArguments);
        };
        log("Creating BuidlerRuntimeEnvironment");
        const networkName = buidlerArguments.network !== undefined
            ? buidlerArguments.network
            : config.defaultNetwork;
        const networkConfig = config.networks[networkName];
        if (networkConfig === undefined) {
            throw new errors_1.BuidlerError(errors_list_1.ERRORS.NETWORK.CONFIG_NOT_FOUND, {
                network: networkName
            });
        }
        const provider = lazy_1.lazyObject(() => {
            log(`Creating provider for network ${networkName}`);
            return construction_1.createProvider(networkName, networkConfig, config.solc.version, config.paths);
        });
        this.network = {
            name: networkName,
            config: config.networks[networkName],
            provider
        };
        this.ethereum = provider;
        this._extenders = extenders;
        extenders.forEach(extender => extender(this));
    }
    /**
     * Injects the properties of `this` (the Buidler Runtime Environment) into the global scope.
     *
     * @param blacklist a list of property names that won't be injected.
     *
     * @returns a function that restores the previous environment.
     */
    injectToGlobal(blacklist = Environment._BLACKLISTED_PROPERTIES) {
        const globalAsAny = global;
        const previousValues = {};
        for (const [key, value] of Object.entries(this)) {
            if (blacklist.includes(key)) {
                continue;
            }
            previousValues[key] = globalAsAny[key];
            globalAsAny[key] = value;
        }
        return () => {
            for (const [key, _] of Object.entries(this)) {
                if (blacklist.includes(key)) {
                    continue;
                }
                globalAsAny[key] = previousValues[key];
            }
        };
    }
    async _runTaskDefinition(taskDefinition, taskArguments) {
        let runSuperFunction;
        if (taskDefinition instanceof task_definitions_1.OverriddenTaskDefinition) {
            runSuperFunction = async (_taskArguments = taskArguments) => {
                log("Running %s's super", taskDefinition.name);
                return this._runTaskDefinition(taskDefinition.parentTaskDefinition, _taskArguments);
            };
            runSuperFunction.isDefined = true;
        }
        else {
            runSuperFunction = async () => {
                throw new errors_1.BuidlerError(errors_list_1.ERRORS.TASK_DEFINITIONS.RUNSUPER_NOT_AVAILABLE, {
                    taskName: taskDefinition.name
                });
            };
            runSuperFunction.isDefined = false;
        }
        const runSuper = runSuperFunction;
        const globalAsAny = global;
        const previousRunSuper = globalAsAny.runSuper;
        globalAsAny.runSuper = runSuper;
        const uninjectFromGlobal = this.injectToGlobal();
        try {
            return await taskDefinition.action(taskArguments, this, runSuper);
        }
        finally {
            uninjectFromGlobal();
            globalAsAny.runSuper = previousRunSuper;
        }
    }
}
Environment._BLACKLISTED_PROPERTIES = [
    "injectToGlobal",
    "_runTaskDefinition"
];
exports.Environment = Environment;
//# sourceMappingURL=runtime-environment.js.map